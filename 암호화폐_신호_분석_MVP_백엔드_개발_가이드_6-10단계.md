# 🚀 암호화폐 신호 분석 MVP 백엔드 개발 가이드 (6-10단계)

## 🔗 6단계: API 엔드포인트 개발 (5-6주차)

### RESTful API 라우트 설계
```javascript
// src/routes/signals.js
const express = require('express');
const router = express.Router();
const Signal = require('../models/Signal');
const Coin = require('../models/Coin');
const { validationResult, query, param } = require('express-validator');

// 전체 신호 조회 (페이징 지원)
router.get('/', [
  query('page').optional().isInt({ min: 1 }).withMessage('페이지는 1 이상의 정수여야 합니다'),
  query('limit').optional().isInt({ min: 1, max: 100 }).withMessage('제한은 1-100 사이여야 합니다'),
  query('sort').optional().isIn(['score', 'rank', 'updated']).withMessage('잘못된 정렬 기준'),
  query('filter').optional().isIn(['strong_buy', 'buy', 'hold', 'sell', 'strong_sell']),
  query('timeframe').optional().isIn(['SCALPING', 'DAY_TRADING', 'SWING_TRADING', 'LONG_TERM']),
  query('min_score').optional().isInt({ min: 0, max: 100 }),
  query('max_score').optional().isInt({ min: 0, max: 100 })
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 50;
    const sort = req.query.sort || 'score';
    const filter = req.query.filter;
    const timeframe = req.query.timeframe;
    const minScore = parseInt(req.query.min_score) || 0;
    const maxScore = parseInt(req.query.max_score) || 100;

    // 쿼리 조건 구성
    let queryConditions = {
      finalScore: { $gte: minScore, $lte: maxScore }
    };

    if (filter) {
      const actionMap = {
        'strong_buy': 'STRONG_BUY',
        'buy': 'BUY', 
        'hold': 'HOLD',
        'sell': 'SELL',
        'strong_sell': 'STRONG_SELL'
      };
      queryConditions['recommendation.action'] = actionMap[filter];
    }

    if (timeframe) {
      queryConditions.timeframe = timeframe;
    }

    // 정렬 옵션
    let sortOptions = {};
    switch (sort) {
      case 'score':
        sortOptions = { finalScore: -1 };
        break;
      case 'rank':
        sortOptions = { rank: 1 };
        break;
      case 'updated':
        sortOptions = { updatedAt: -1 };
        break;
    }

    const signals = await Signal.find(queryConditions)
      .sort(sortOptions)
      .limit(limit)
      .skip((page - 1) * limit)
      .lean();

    const total = await Signal.countDocuments(queryConditions);

    res.json({
      success: true,
      data: signals,
      pagination: {
        current_page: page,
        total_pages: Math.ceil(total / limit),
        total_items: total,
        items_per_page: limit
      }
    });

  } catch (error) {
    console.error('신호 조회 실패:', error);
    res.status(500).json({ 
      success: false, 
      error: '서버 오류가 발생했습니다' 
    });
  }
});

// 특정 코인 신호 조회
router.get('/coin/:coinId', [
  param('coinId').notEmpty().withMessage('코인 ID는 필수입니다')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const { coinId } = req.params;
    const signal = await Signal.findOne({ coinId }).lean();

    if (!signal) {
      return res.status(404).json({
        success: false,
        error: '해당 코인의 신호를 찾을 수 없습니다'
      });
    }

    res.json({
      success: true,
      data: signal
    });

  } catch (error) {
    console.error('코인 신호 조회 실패:', error);
    res.status(500).json({ 
      success: false, 
      error: '서버 오류가 발생했습니다' 
    });
  }
});

// 코인 검색
router.get('/search', [
  query('q').notEmpty().withMessage('검색어는 필수입니다'),
  query('limit').optional().isInt({ min: 1, max: 50 })
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const searchQuery = req.query.q.toLowerCase();
    const limit = parseInt(req.query.limit) || 20;

    const signals = await Signal.find({
      $or: [
        { coinId: { $regex: searchQuery, $options: 'i' } },
        { symbol: { $regex: searchQuery, $options: 'i' } },
        { name: { $regex: searchQuery, $options: 'i' } }
      ]
    })
    .sort({ finalScore: -1 })
    .limit(limit)
    .lean();

    res.json({
      success: true,
      data: signals,
      count: signals.length
    });

  } catch (error) {
    console.error('코인 검색 실패:', error);
    res.status(500).json({ 
      success: false, 
      error: '서버 오류가 발생했습니다' 
    });
  }
});

// 강한 신호 조회 (점수 80 이상 또는 20 이하)
router.get('/strong', async (req, res) => {
  try {
    const strongSignals = await Signal.find({
      $or: [
        { finalScore: { $gte: 80 } },
        { finalScore: { $lte: 20 } }
      ]
    })
    .sort({ finalScore: -1 })
    .limit(100)
    .lean();

    res.json({
      success: true,
      data: strongSignals,
      count: strongSignals.length
    });

  } catch (error) {
    console.error('강한 신호 조회 실패:', error);
    res.status(500).json({ 
      success: false, 
      error: '서버 오류가 발생했습니다' 
    });
  }
});

// 신호 통계
router.get('/stats', async (req, res) => {
  try {
    const stats = await Signal.aggregate([
      {
        $group: {
          _id: null,
          totalCoins: { $sum: 1 },
          avgScore: { $avg: '$finalScore' },
          strongBuyCount: {
            $sum: { $cond: [{ $eq: ['$recommendation.action', 'STRONG_BUY'] }, 1, 0] }
          },
          buyCount: {
            $sum: { $cond: [{ $eq: ['$recommendation.action', 'BUY'] }, 1, 0] }
          },
          holdCount: {
            $sum: { $cond: [{ $eq: ['$recommendation.action', 'HOLD'] }, 1, 0] }
          },
          sellCount: {
            $sum: { $cond: [{ $eq: ['$recommendation.action', 'SELL'] }, 1, 0] }
          },
          strongSellCount: {
            $sum: { $cond: [{ $eq: ['$recommendation.action', 'STRONG_SELL'] }, 1, 0] }
          }
        }
      }
    ]);

    const timeframeStats = await Signal.aggregate([
      {
        $group: {
          _id: '$timeframe',
          count: { $sum: 1 },
          avgScore: { $avg: '$finalScore' }
        }
      }
    ]);

    res.json({
      success: true,
      data: {
        overview: stats[0] || {},
        timeframes: timeframeStats
      }
    });

  } catch (error) {
    console.error('신호 통계 조회 실패:', error);
    res.status(500).json({ 
      success: false, 
      error: '서버 오류가 발생했습니다' 
    });
  }
});

module.exports = router;

// src/routes/coins.js
const express = require('express');
const router = express.Router();
const Coin = require('../models/Coin');

// 전체 코인 리스트
router.get('/', async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 50;
    const sort = req.query.sort || 'marketCapRank';

    const coins = await Coin.find()
      .sort({ [sort]: 1 })
      .limit(limit)
      .skip((page - 1) * limit)
      .lean();

    const total = await Coin.countDocuments();

    res.json({
      success: true,
      data: coins,
      pagination: {
        current_page: page,
        total_pages: Math.ceil(total / limit),
        total_items: total
      }
    });

  } catch (error) {
    console.error('코인 리스트 조회 실패:', error);
    res.status(500).json({ 
      success: false, 
      error: '서버 오류가 발생했습니다' 
    });
  }
});

// 특정 코인 상세 정보
router.get('/:coinId', async (req, res) => {
  try {
    const { coinId } = req.params;
    const coin = await Coin.findOne({ coinId }).lean();

    if (!coin) {
      return res.status(404).json({
        success: false,
        error: '코인을 찾을 수 없습니다'
      });
    }

    // 해당 코인의 최신 신호도 함께 반환
    const Signal = require('../models/Signal');
    const signal = await Signal.findOne({ coinId }).lean();

    res.json({
      success: true,
      data: {
        coin,
        signal
      }
    });

  } catch (error) {
    console.error('코인 상세 조회 실패:', error);
    res.status(500).json({ 
      success: false, 
      error: '서버 오류가 발생했습니다' 
    });
  }
});

module.exports = router;

// src/routes/alerts.js  
const express = require('express');
const router = express.Router();
const Alert = require('../models/Alert');

// 알림 설정 생성
router.post('/', async (req, res) => {
  try {
    const { coinId, alertType, settings } = req.body;

    const alert = new Alert({
      coinId,
      alertType,
      settings,
      isTriggered: false
    });

    await alert.save();

    res.status(201).json({
      success: true,
      data: alert
    });

  } catch (error) {
    console.error('알림 설정 생성 실패:', error);
    res.status(500).json({ 
      success: false, 
      error: '서버 오류가 발생했습니다' 
    });
  }
});

// 발생한 알림 조회
router.get('/triggered', async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;

    const alerts = await Alert.find({ isTriggered: true })
      .sort({ triggeredAt: -1 })
      .limit(limit)
      .skip((page - 1) * limit)
      .lean();

    const total = await Alert.countDocuments({ isTriggered: true });

    res.json({
      success: true,
      data: alerts,
      pagination: {
        current_page: page,
        total_pages: Math.ceil(total / limit),
        total_items: total
      }
    });

  } catch (error) {
    console.error('알림 조회 실패:', error);
    res.status(500).json({ 
      success: false, 
      error: '서버 오류가 발생했습니다' 
    });
  }
});

module.exports = router;
```

---

## 🔧 7단계: 배포 및 인프라 설정 (6-7주차)

### Docker 컨테이너화
```dockerfile
# Dockerfile
FROM node:18-alpine

WORKDIR /app

# 의존성 설치
COPY package*.json ./
RUN npm ci --only=production

# 앱 코드 복사
COPY . .

# 환경 설정
ENV NODE_ENV=production
ENV PORT=3000

EXPOSE 3000

# 헬스체크
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node healthcheck.js

CMD ["npm", "start"]

# docker-compose.yml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - MONGODB_URI=mongodb://mongo:27017/crypto-signals
      - REDIS_URL=redis://redis:6379
    depends_on:
      - mongo
      - redis
    restart: unless-stopped

  mongo:
    image: mongo:5.0
    ports:
      - "27017:27017"
    volumes:
      - mongo_data:/data/db
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    restart: unless-stopped

volumes:
  mongo_data:
```

### Vercel 서버리스 배포 설정
```javascript
// vercel.json
{
  "version": 2,
  "builds": [
    {
      "src": "src/app.js",
      "use": "@vercel/node"
    }
  ],
  "routes": [
    {
      "src": "/api/(.*)",
      "dest": "src/app.js"
    }
  ],
  "env": {
    "NODE_ENV": "production",
    "MONGODB_URI": "@mongodb_uri",
    "REDIS_URL": "@redis_url",
    "COINGECKO_API_KEY": "@coingecko_api_key"
  }
}

// api/index.js (Vercel 엔트리포인트)
const app = require('../src/app');
module.exports = app;
```

### Railway 배포 설정 (권장)
```toml
# railway.toml
[build]
builder = "NIXPACKS"

[deploy]
healthcheckPath = "/api/health"
healthcheckTimeout = 300
restartPolicyType = "ALWAYS"

[[services]]
name = "crypto-signal-backend"

[services.database]
plugin = "mongodb"

[services.redis]
plugin = "redis"
```

### 환경별 설정 관리
```javascript
// config/database.js
const mongoose = require('mongoose');

class DatabaseConfig {
  static async connect() {
    try {
      const mongoUri = process.env.MONGODB_URI || 'mongodb://localhost:27017/crypto-signals';
      
      await mongoose.connect(mongoUri, {
        useNewUrlParser: true,
        useUnifiedTopology: true,
        maxPoolSize: 10,
        serverSelectionTimeoutMS: 5000,
        socketTimeoutMS: 45000,
        bufferCommands: false,
        bufferMaxEntries: 0
      });

      console.log('✅ MongoDB 연결 성공');

      // 연결 이벤트 리스너
      mongoose.connection.on('error', (err) => {
        console.error('MongoDB 연결 오류:', err);
      });

      mongoose.connection.on('disconnected', () => {
        console.warn('MongoDB 연결 끊어짐');
      });

    } catch (error) {
      console.error('MongoDB 연결 실패:', error);
      process.exit(1);
    }
  }

  static async disconnect() {
    await mongoose.disconnect();
    console.log('MongoDB 연결 종료');
  }
}

module.exports = DatabaseConfig;

// config/redis.js
const Redis = require('ioredis');

class RedisConfig {
  static createConnection() {
    const redis = new Redis(process.env.REDIS_URL || 'redis://localhost:6379', {
      retryDelayOnFailover: 100,
      enableReadyCheck: false,
      maxRetriesPerRequest: null,
      lazyConnect: true
    });

    redis.on('connect', () => {
      console.log('✅ Redis 연결 성공');
    });

    redis.on('error', (err) => {
      console.error('Redis 연결 오류:', err);
    });

    return redis;
  }
}

module.exports = RedisConfig;
```

---

## 📊 8단계: 모니터링 및 로깅 (7-8주차)

### Winston 로거 설정
```javascript
// src/utils/logger.js
const winston = require('winston');
const path = require('path');

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { service: 'crypto-signal-backend' },
  transports: [
    // 콘솔 출력
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      )
    }),
    
    // 파일 로그 (에러)
    new winston.transports.File({
      filename: path.join('logs', 'error.log'),
      level: 'error'
    }),
    
    // 파일 로그 (전체)
    new winston.transports.File({
      filename: path.join('logs', 'combined.log')
    })
  ]
});

// 프로덕션 환경에서 콘솔 로그 제거
if (process.env.NODE_ENV === 'production') {
  logger.remove(winston.transports.Console);
}

module.exports = logger;

// src/middleware/logging.js
const logger = require('../utils/logger');

const requestLogger = (req, res, next) => {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = Date.now() - start;
    logger.info('HTTP Request', {
      method: req.method,
      url: req.url,
      statusCode: res.statusCode,
      duration: `${duration}ms`,
      userAgent: req.get('User-Agent'),
      ip: req.ip
    });
  });
  
  next();
};

module.exports = { requestLogger };
```

### 성능 모니터링 미들웨어
```javascript
// src/middleware/monitoring.js
const logger = require('../utils/logger');

class PerformanceMonitor {
  static trackApiPerformance() {
    return (req, res, next) => {
      const start = process.hrtime.bigint();
      
      res.on('finish', () => {
        const duration = Number(process.hrtime.bigint() - start) / 1000000; // ms
        
        // 느린 요청 로깅 (500ms 이상)
        if (duration > 500) {
          logger.warn('Slow API Request', {
            method: req.method,
            url: req.url,
            duration: `${duration.toFixed(2)}ms`,
            statusCode: res.statusCode
          });
        }

        // 메트릭 수집 (추후 Prometheus 연동 가능)
        this.collectMetrics(req.method, req.route?.path || req.url, duration, res.statusCode);
      });
      
      next();
    };
  }

  static collectMetrics(method, path, duration, statusCode) {
    // 메모리에 메트릭 저장 (간단한 구현)
    const key = `${method}_${path}`;
    
    if (!global.apiMetrics) {
      global.apiMetrics = {};
    }
    
    if (!global.apiMetrics[key]) {
      global.apiMetrics[key] = {
        count: 0,
        totalDuration: 0,
        errors: 0
      };
    }
    
    global.apiMetrics[key].count++;
    global.apiMetrics[key].totalDuration += duration;
    
    if (statusCode >= 400) {
      global.apiMetrics[key].errors++;
    }
  }

  static getMetrics() {
    return global.apiMetrics || {};
  }
}

module.exports = PerformanceMonitor;
```

### 헬스 체크 엔드포인트
```javascript
// src/routes/health.js
const express = require('express');
const router = express.Router();
const mongoose = require('mongoose');
const PerformanceMonitor = require('../middleware/monitoring');
const logger = require('../utils/logger');

router.get('/', async (req, res) => {
  try {
    const healthCheck = {
      status: 'OK',
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      memory: process.memoryUsage(),
      version: process.env.npm_package_version || '1.0.0'
    };

    // 데이터베이스 연결 체크
    if (mongoose.connection.readyState === 1) {
      healthCheck.database = 'Connected';
    } else {
      healthCheck.database = 'Disconnected';
      healthCheck.status = 'WARNING';
    }

    // Redis 연결 체크
    try {
      const Redis = require('ioredis');
      const redis = new Redis(process.env.REDIS_URL);
      await redis.ping();
      healthCheck.redis = 'Connected';
      redis.disconnect();
    } catch (error) {
      healthCheck.redis = 'Disconnected';
      healthCheck.status = 'WARNING';
    }

    // API 메트릭 포함
    healthCheck.metrics = PerformanceMonitor.getMetrics();

    res.status(healthCheck.status === 'OK' ? 200 : 503).json(healthCheck);

  } catch (error) {
    logger.error('Health check failed', error);
    res.status(503).json({
      status: 'ERROR',
      timestamp: new Date().toISOString(),
      error: error.message
    });
  }
});

module.exports = router;
```

---

## 🚀 9단계: 통합 및 테스트 (8-9주차)

### 유닛 테스트
```javascript
// tests/services/SignalCalculator.test.js
const { expect } = require('chai');
const SignalCalculatorService = require('../../src/services/SignalCalculatorService');

describe('SignalCalculatorService', () => {
  let signalCalculator;

  beforeEach(() => {
    signalCalculator = new SignalCalculatorService();
  });

  describe('calculatePriceScore', () => {
    it('should return high score for positive momentum', () => {
      const coinData = {
        price_change_percentage_1h: 5,
        price_change_percentage_24h: 10,
        price_change_percentage_7d: 15,
        price_change_percentage_30d: 20
      };

      const score = signalCalculator.calculatePriceScore(coinData);
      expect(score).to.be.above(70);
    });

    it('should return low score for negative momentum', () => {
      const coinData = {
        price_change_percentage_1h: -5,
        price_change_percentage_24h: -10,
        price_change_percentage_7d: -15,
        price_change_percentage_30d: -20
      };

      const score = signalCalculator.calculatePriceScore(coinData);
      expect(score).to.be.below(30);
    });
  });

  describe('calculateVolumeScore', () => {
    it('should return high score for high volume ratio', () => {
      const coinData = {
        market_cap: 1000000000,
        total_volume: 600000000
      };

      const score = signalCalculator.calculateVolumeScore(coinData);
      expect(score).to.equal(90);
    });
  });
});

// tests/api/signals.test.js
const request = require('supertest');
const app = require('../../src/app');

describe('Signals API', () => {
  describe('GET /api/signals', () => {
    it('should return signals with pagination', async () => {
      const response = await request(app)
        .get('/api/signals?page=1&limit=10')
        .expect(200);

      expect(response.body).to.have.property('success', true);
      expect(response.body).to.have.property('data');
      expect(response.body).to.have.property('pagination');
      expect(response.body.data).to.be.an('array');
    });

    it('should filter signals by score range', async () => {
      const response = await request(app)
        .get('/api/signals?min_score=80')
        .expect(200);

      response.body.data.forEach(signal => {
        expect(signal.finalScore).to.be.at.least(80);
      });
    });
  });

  describe('GET /api/signals/search', () => {
    it('should search coins by symbol', async () => {
      const response = await request(app)
        .get('/api/signals/search?q=bitcoin')
        .expect(200);

      expect(response.body.success).to.be.true;
      expect(response.body.data).to.be.an('array');
    });

    it('should return 400 for empty search query', async () => {
      await request(app)
        .get('/api/signals/search')
        .expect(400);
    });
  });
});
```

### 통합 테스트
```javascript
// tests/integration/dataFlow.test.js
describe('Data Flow Integration', () => {
  it('should process coin data end-to-end', async () => {
    // 1. CoinGecko API에서 데이터 가져오기
    const coinGeckoService = new CoinGeckoService();
    const marketData = await coinGeckoService.getMarketDataBatch(1, 1);
    
    expect(marketData).to.have.length(1);
    
    // 2. 신호 계산
    const signalCalculator = new SignalCalculatorService();
    const signal = await signalCalculator.calculateSignal(marketData[0]);
    
    expect(signal).to.have.property('finalScore');
    expect(signal.finalScore).to.be.a('number');
    expect(signal.finalScore).to.be.within(0, 100);
    
    // 3. 데이터베이스 저장
    const Signal = require('../../src/models/Signal');
    const savedSignal = await Signal.create(signal);
    
    expect(savedSignal._id).to.exist;
    
    // 4. API를 통한 조회
    const response = await request(app)
      .get(`/api/signals/coin/${signal.coinId}`)
      .expect(200);
    
    expect(response.body.data.coinId).to.equal(signal.coinId);
  });
});
```

---

## 📱 10단계: 최종 배포 및 문서화 (9-10주차)

### API 문서 생성 (Swagger)
```javascript
// swagger.js
const swaggerJsdoc = require('swagger-jsdoc');
const swaggerUi = require('swagger-ui-express');

const options = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'Crypto Signal API',
      version: '1.0.0',
      description: '암호화폐 신호 분석 API',
    },
    servers: [
      {
        url: process.env.API_URL || 'http://localhost:3000',
        description: 'Development server',
      },
    ],
  },
  apis: ['./src/routes/*.js'], // API 문서가 있는 파일 경로
};

const specs = swaggerJsdoc(options);

module.exports = { swaggerUi, specs };

/**
 * @swagger
 * /api/signals:
 *   get:
 *     summary: 신호 목록 조회
 *     tags: [Signals]
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           minimum: 1
 *         description: 페이지 번호
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           minimum: 1
 *           maximum: 100
 *         description: 페이지당 항목 수
 *     responses:
 *       200:
 *         description: 성공
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Signal'
 */
```

### 프로덕션 배포 스크립트
```bash
#!/bin/bash
# deploy.sh

set -e

echo "🚀 암호화폐 신호 백엔드 배포 시작"

# 환경 변수 체크
if [ -z "$MONGODB_URI" ]; then
    echo "❌ MONGODB_URI 환경변수가 설정되지 않았습니다"
    exit 1
fi

if [ -z "$REDIS_URL" ]; then
    echo "❌ REDIS_URL 환경변수가 설정되지 않았습니다"
    exit 1
fi

# 의존성 설치
echo "📦 의존성 설치 중..."
npm ci --production

# 데이터베이스 마이그레이션 (필요시)
echo "🗄️ 데이터베이스 설정 확인 중..."
npm run db:migrate

# 빌드 (필요시)
echo "🔨 빌드 중..."
npm run build

# 헬스 체크
echo "🏥 헬스 체크 중..."
curl -f http://localhost:3000/api/health || exit 1

# PM2로 프로세스 관리 (선택사항)
if command -v pm2 &> /dev/null; then
    echo "🔄 PM2로 서비스 재시작 중..."
    pm2 restart crypto-signal-backend || pm2 start ecosystem.config.js
else
    echo "🚀 서비스 시작 중..."
    npm start
fi

echo "✅ 배포 완료!"
```

### 환경별 설정 파일
```javascript
// ecosystem.config.js (PM2 설정)
module.exports = {
  apps: [{
    name: 'crypto-signal-backend',
    script: './src/server.js',
    instances: 'max',
    exec_mode: 'cluster',
    env: {
      NODE_ENV: 'development',
      PORT: 3000
    },
    env_production: {
      NODE_ENV: 'production',
      PORT: 3000
    },
    log_file: './logs/combined.log',
    error_file: './logs/error.log',
    out_file: './logs/out.log',
    log_date_format: 'YYYY-MM-DD HH:mm Z',
    max_memory_restart: '1G',
    node_args: '--max_old_space_size=1024'
  }]
};
```

### 최종 서버 진입점
```javascript
// src/server.js
const app = require('./app');
const DatabaseConfig = require('../config/database');
const logger = require('./utils/logger');
const SchedulerService = require('./services/SchedulerService');

const PORT = process.env.PORT || 3000;

// 우아한 종료 처리
process.on('SIGTERM', gracefulShutdown);
process.on('SIGINT', gracefulShutdown);

async function startServer() {
  try {
    // 데이터베이스 연결
    await DatabaseConfig.connect();
    
    // 스케줄러 시작
    const scheduler = new SchedulerService();
    scheduler.startScheduler();
    
    // 서버 시작
    const server = app.listen(PORT, () => {
      logger.info(`🚀 서버가 포트 ${PORT}에서 실행 중입니다`);
      logger.info(`📚 API 문서: http://localhost:${PORT}/api-docs`);
      logger.info(`🏥 헬스 체크: http://localhost:${PORT}/api/health`);
    });

    // 서버 참조 저장 (우아한 종료용)
    global.server = server;
    global.scheduler = scheduler;

  } catch (error) {
    logger.error('서버 시작 실패:', error);
    process.exit(1);
  }
}

async function gracefulShutdown(signal) {
  logger.info(`${signal} 신호 수신. 우아한 종료 시작...`);
  
  try {
    // 새 요청 수락 중지
    if (global.server) {
      global.server.close();
    }
    
    // 스케줄러 중지
    if (global.scheduler) {
      global.scheduler.stopScheduler();
    }
    
    // 데이터베이스 연결 종료
    await DatabaseConfig.disconnect();
    
    logger.info('✅ 우아한 종료 완료');
    process.exit(0);
  } catch (error) {
    logger.error('종료 중 오류:', error);
    process.exit(1);
  }
}

startServer();
```

---

## 📋 개발 체크리스트 (6-10단계)

### 6주차: API 개발
- [ ] RESTful 엔드포인트 구현
- [ ] 페이징 및 필터링
- [ ] 검색 기능
- [ ] 입력 유효성 검사

### 7주차: 배포 준비
- [ ] Docker 컨테이너화
- [ ] 환경별 설정 분리
- [ ] 로깅 시스템 구현
- [ ] 모니터링 설정

### 8주차: 테스트
- [ ] 유닛 테스트 작성
- [ ] 통합 테스트 구현
- [ ] API 테스트
- [ ] 성능 테스트

### 9주차: 문서화
- [ ] API 문서 생성
- [ ] README 작성
- [ ] 배포 가이드 작성
- [ ] 운영 매뉴얼

### 10주차: 최종 배포
- [ ] 프로덕션 배포
- [ ] 모니터링 설정
- [ ] 알림 시스템 테스트
- [ ] 성능 최적화

---

## 💡 주요 고려사항

### 비용 최적화
- **무료 티어 최대 활용**: MongoDB Atlas 무료 512MB, Redis Cloud 무료 30MB
- **서버리스 우선**: Vercel/Netlify Functions 활용
- **CDN 활용**: 정적 자원 캐싱으로 트래픽 비용 절약

### 성능 최적화
- **지능적인 캐싱**: Redis 활용한 다층 캐시 전략
- **배치 처리**: API 호출 최소화
- **인덱싱**: MongoDB 쿼리 최적화

### 확장성 고려
- **마이크로서비스 준비**: 모듈별 분리 가능한 구조
- **큐 시스템**: 수평 확장 가능한 작업 처리
- **데이터베이스 샤딩**: 대용량 데이터 처리 준비

---

**이제 완전한 10단계 개발 가이드가 완성되었습니다!** 🎉

이 가이드를 따라 구현하면 **100% 무료 API만으로 17,000개 이상의 모든 암호화폐를 실시간 분석**하는 강력한 백엔드 시스템을 구축할 수 있습니다!
